<!DOCTYPE html>
<html>
<head>
  <title>Google Streetview Dates</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">

  <script src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap" async defer></script>


  <script>
    let map;
    let debounceTimer;

function initMap() {
  map = new google.maps.Map(document.getElementById("map"), {
    center: { lat: 51.5098, lng: -0.1180 },
    zoom: 5,
  });

// Display the initial zoom level
  updateZoomLevelIndicator();

  
google.maps.event.addListener(map, "zoom_changed", () => {
  updateZoomLevelIndicator(); //Update zoom level indicator
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    if (map.getZoom() >= 15) {
      populateTableWithVisibleStreets();
    } else {
      clearTable();
    }
  }, 1500); // Adjust the debounce time in milliseconds as needed
});

google.maps.event.addListener(map, "bounds_changed", () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    if (map.getZoom() >= 15) {
      populateTableWithVisibleStreets();
    } else {
      clearTable();
    }
  }, 1500); // Adjust the debounce time in milliseconds as needed
});

}

function updateZoomLevelIndicator() {
  const zoomLevelElement = document.getElementById("zoom-level");
  const zoomLevelContainer = document.getElementById("zoom-level-container");
  const zoomLevel = map.getZoom();
  zoomLevelElement.textContent = zoomLevel;

  if (zoomLevel > 15) {
    zoomLevelContainer.classList.add("hidden");
  } else {
    zoomLevelContainer.classList.remove("hidden");
  }
}
    
function populateTableWithVisibleStreets() {
  const bounds = map.getBounds();
  const northEast = bounds.getNorthEast();
  const southWest = bounds.getSouthWest();

  const overpassQuery = `
    [out:json][timeout:25];
    (
      way[highway][name](${southWest.lat()},${southWest.lng()},${northEast.lat()},${northEast.lng()});
    );
    out body;
  `;

  const overpassApiUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery.trim())}`;

  fetch(overpassApiUrl)
    .then((response) => response.json())
    .then((data) => {
      const streetNames = data.elements
        .filter((element) => element.tags && element.tags.name)
        .map((element) => element.tags.name);
      const uniqueStreetNames = [...new Set(streetNames)];
      populateTable(uniqueStreetNames, '{{ google_maps_api_key }}'); // Pass the API key as a string
    })
    .catch((error) => {
      console.error('Error fetching street names:', error);
    });

}


function populateTable(streetNames) {
  const table = document.getElementById("info-table");

  // Clear the table before populating it
  while (table.rows.length > 1) {
    table.deleteRow(1);
  }

  streetNames.forEach(async (streetName) => {
    const row = table.insertRow();
    const cell1 = row.insertCell();
    cell1.textContent = streetName;

    cell1.style.cursor = "pointer"; // Change cursor to pointer when hovering over the street name

    cell1.addEventListener("click", async () => {
      try {
        const streetLatLng = await geocodeStreet(streetName);
        const latLng = new google.maps.LatLng(streetLatLng.lat, streetLatLng.lng);

        // Remove existing marker if any
        if (window.streetMarker) {
          window.streetMarker.setMap(null);
        }

        // Create and place a new marker on the map
        window.streetMarker = new google.maps.Marker({
          position: latLng,
          map: map,
        });

        // Center the map on the marker
        map.setCenter(latLng);
      } catch (error) {
        console.error(`Error placing marker for ${streetName}:`, error);
      }
    });

    // Fetch and display the Street View image date
    await populateRowWithStreetViewImageDate(row, streetName);
  });
}



async function populateRowWithStreetViewImageDate(row, streetName) {
  try {
    const streetLatLng = await geocodeStreet(streetName);
    const latLng = new google.maps.LatLng(streetLatLng.lat, streetLatLng.lng);

    const streetViewService = new google.maps.StreetViewService();
    streetViewService.getPanoramaByLocation(latLng, 50, (data, status) => {
      if (status === google.maps.StreetViewStatus.OK) {
        const imageDate = data.imageDate;
        const cell2 = row.insertCell(1);
        cell2.textContent = imageDate;
      } else {
        const cell2 = row.insertCell(1);
        cell2.textContent = 'No imagery here';
        console.error(`Error fetching Street View image date for ${streetName}: ${status}`);
      }
    });
  } catch (error) {
    console.error(`Error fetching Street View image date for ${streetName}:`, error);
  }
}



async function geocodeStreet(streetName, apiKey) {
  const geocoder = new google.maps.Geocoder();
  const request = {
    address: streetName,
    bounds: map.getBounds(),
  };

  return new Promise((resolve, reject) => {
    geocoder.geocode(request, (results, status) => {
      if (status === "OK") {
        const latLng = results[0].geometry.location;
        resolve({ lat: latLng.lat(), lng: latLng.lng() });
      } else {
        reject(new Error(`Geocoding failed for ${streetName}: ${status}`));
      }
    });
  });
}


    
function clearTable() {
  const table = document.getElementById("info-table");

  if (table) {
    // Clear the table
    while (table.rows.length > 1) {
      table.deleteRow(1);
    }

    // Add a message when zoom level is below 15
    const row = table.insertRow();
    const cell = row.insertCell();
    cell.textContent = "Zoom in to see Streetview data";
    cell.colSpan = 2; // Span the message across both columns
    cell.style.textAlign = "center";
  }
}

async function fetchStreets(center, radius) {
  const overpassApiUrl = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];(way[highway](around:${radius},${center.lat()},${center.lng()}));(._;>;);out body;`;
  const response = await fetch(overpassApiUrl);
  const data = await response.json();
  const streets = data.elements.filter(element => element.type === "way");
  const nodes = data.elements.filter(element => element.type === "node");

  const midPoints = streets.map(street => {
    const streetNodes = street.nodes.map(nodeId => nodes.find(node => node.id === nodeId));
    const midIndex = Math.floor((streetNodes.length - 1) / 2);
    const midPoint = {
      lat: streetNodes[midIndex].lat,
      lon: streetNodes[midIndex].lon
    };
    return midPoint;
  });

  console.log(midPoints);
}
    

  </script>
  <style>
   html, body {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  body {
      font-family: 'Roboto', sans-serif;
    }
    
  #map {
    position: relative;
    height: 70%;
    width: 70%;
    float: left;
    border: 2px solid #dddddd;
    box-sizing: border-box;
  }

  #zoom-level-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
    opacity: 1;
    transition: opacity 0.5s ease;
  }
  
  #zoom-level-container.hidden {
    opacity: 0;
  }

  #info-table-container {
    height: 70%;
    width: 30%;
    float: right;
    overflow-y: auto;
    background-color: #ECEFF1;
    box-sizing: border-box;
  }

  #header {
    width: 100%;
    padding: 20px;
    text-align: left;
    background-color: #ECEFF1;
    font-size: 30px;
    font-weight: bold;
    margin-bottom: 0px;
    box-sizing: border-box;
  }

  #description {
    width: 100%;
    padding: 5px;
    text-align: left;
    background-color: #f8f9fa;
    font-size: 16px;
    margin-top: 0px;
    margin-bottom: 20px;
    box-sizing: border-box;
  }
    
  .clearfix::after {
    content: "";
    display: table;
    clear: both;
  }

  table {
    border-collapse: collapse;
    width: 100%;
    
  }

  th, td {
    border: 2px solid #dddddd;
    text-align: left;
    padding: 8px;
    background-color: #CFD8DC
  }

  th {
    background-color: #CFD8DC;
  }
</style>

</head>
<body onload="initMap()">
  <div id="header">Google Streetview Dates Viewer</div>
  <div id="map"></div>
    <div id="zoom-level-container">Zoom Level: <span id="zoom-level"></span></div>
  </div>
  
  <div id="info-table-container">
		<table id="info-table">
  <tr>
    <th>Name</th>
    <th>Date</th>
  </tr>
  <!-- The table rows will be added dynamically -->
	</table>
	  </div>
  <div class="clearfix"></div>
  <div id="description">
    <p></p>
      <h3>Description</h3>
      <p>
        Google Streetview Dates Viewer is an interactive mapping application that displays street names in a specific area on the map and their corresponding latest Street View image date. The app allows users to quickly see how up to date street-level imagery is for a given location without needing to enter a Streetview panorama view.
      </p>
      <h3>How to use:</h3>
      <ol>
        <li>Open the web app in your browser. You will see a Google Map view on the left side of the screen and an initially empty data table on the right side.</li>
        <li>Navigate the map as desired. When you reach zoom level 15 or higher, the app will automatically populate the data table with the visible street names and their latest Street View image date.</li>
        <li>If there is no Street View imagery available for a specific street, the table will display "No imagery here" in the date column.</li>
        <li>To view the location of a particular street on the map, click on the street name in the data table. A marker will appear on the map.</li>
        <li>To clear the table and remove all markers from the map, zoom out.</li>
		<li>As you pan and zoom the map, the data table will update automatically.</li>
		</ol>
		</div>

	</body>
	</html>
